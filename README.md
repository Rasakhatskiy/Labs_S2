## Лаба 1  
5. ***Інформація про повідомлення у децентралізованій соціальній мережі ***
(є багато серверів, на кожному сервері до 40000 користувачів, повідомлення в рамках одного серверу). 
Для кожного повідомлення зберігаються такі дані: 
 - текст повідомлення; 
 - точна дата і час відправлення повідомлення; 
 - користувач-автор повідомлення; адресат повідомлення (існує спеціальний адресат, що позначає повідомлення для всіх); 
 - тип повідомлення – новини, питання, відповідь на питання, запрошення на подію, коментар до іншого повідомлення; 
 - оцінка повідомлення від системи боротьби зі спамом (дійсне невід’ємне число, чим ближче до 0 – тим менше шансів, що це спам). 
Критерії пошуку:
***c) ***
 - Повідомлення, що містять заданий фрагмент тексту; 
 - повідомлення з оцінкою у заданому діапазоні від заданого автора; 
 - повідомлення заданого типу, надіслані до заданого часу.  

## Лаба 2 A  
***Реалізувати структуру даних «циклічний список» з наступними операціями: ***
1) create_empty – створення пустого списку;  
2) insert – вставка елементу перед елементом з індексом k;  
3) remove – видалення елементу з індексом k;   
4) get, set – доступ до елементу за індексом.  

В структурі зберігаються точки у тривимірному просторі (дійсні координати)  

## Лаба 2 B  
14.	(2 зірочки) ***Реалізувати структуру даних «черга з пріоритетами» ***  
(Priority Queue) на основі зв’язного списку.  
Під час додавання елементів вказується значення та пріоритет.  
Елементи з меншим значенням пріоритету вставляються раніше за елементи з більшим значенням.  
Елементи з однаковим значенням вставляються в порядку додавання.  

32. (3 зірочки) ***Змоделювати поведінку планувальника задач (job scheduler) з можливістю переривання виконання.*** 
Задачі можуть перериватись, при цьому починає виконуватись інша задача, а перервана задача повертається в чергу і може виконуватись в майбутньому.  
Реалізувати схеми роботи Shortest Remaining Time First (SRTF) – першою виконується задача з найменшим часом, що лишився (якщо надходить задача з часом, меншим за час виконання поточної задачі – виконується переривання) та Fixed Priority – кожній задачі присвоюється пріоритет, задачі з високим пріоритетом переривають виконання задач з нижчим пріоритетом.  

## Лаба 3 А  
Реалізувати алгоритми сортування для заданої структури даних (список 1).   
Реалізувати наступні алгоритми:  
 - простий алгоритм (список 2);  
 - більш ефективний алгоритм quicksort (список 3);  
 - більш ефективний алгоритм merge sort (список 4);  
 - комбінований алгоритм, який використовує більш ефективний алгоритм (один з quicksort чи merge sort) для великих масивів і простий алгоритм для маленький масивів;  
 - сортування з використанням бібліотечних функцій.  

Варіантом у цій лабораторній роботі є вибір по одному пункту зі списків 1,2,3,4.  

Список 1: структури даних для сортування  
10. Координати точок в тривимірному просторі (дійсні), сортування за x-y-z, за спаданням  

Список 2: прості алгоритми сортування:  
2. Insertion sort  

Список 3: Ефективний алгоритм сортування quicksort:  
4. Hoare partition scheme, rightmost pivot  

Список 4: Ефективний алгоритм сортування merge sort:  
2. top-down, small lists  
 

## Лаба 3 B

В цій лабораторній роботі треба розширити можливості програми, реалізованої в лабораторній роботі № 1. Необхідно додати можливість сортування даних за довільним полем чи за довільною комбінацією полів (тобто спершу за полем1, якщо там однакові значення – за полем2.  
Для реалізації сортування використати один з ефективних алгоритмів сортування (comparison sort зі складністю в середньому O(n log n), наприклад, quicksort, merge sort, heapsort, …). Можна також використати бібліотечну реалізацію сортування.  
Крім цього, необхідно реалізувати два алгоритми сортування, які не є comparison sort:

1. Counting sort
2. Radix sort
Треба реалізувати стабільні версії цих алгоритмів (тобто не переставляються елементи з однаковим значенням ключа сортування). 
Варіант цієї лабораторної роботи співпадає з варіантом лабораторної роботи №1. Варіант також визначає, які поля треба сортувати з використанням додаткових алгоритмів:

5. Counting sort за типом повідомлення, Radix sort за ID користувача Виміряти і порівняти швидкість сортування з використанням comparison sort та додаткових алгоритмів.  
Порівняння має включати як сортування лише за відповідним полем, так і сортування за комбінацією полів, яка включає в себе ці поля. Порівняння має виконуватись на однакових даних.   
Ця лабораторна робота передбачає сортування в пам’яті.  
Можна додатково реалізувати сортування даних у файлі, чи сортування засобами БД, і порівняти їх з вже реалізованими варіантами сортування в пам’яті.  
За це можна отримати додаткові бали.  

## Лаба 3 C



## Лаба 4

Завдання цієї лабораторної організовано у вигляді дерева.  
Окремі завдання є вузлами дерева.  
Варіант лабораторної відповідає шляху від кореня до листових вузлів.  
Дерево будується, починаючи з кореня (блок 0) і послідовно додаючи вузли з наступних блоків.  
У кожному варіанті може бути декілька вузлів одного блоку.  
Якщо вузли помічено позначкою Core – то такі вузли обов’язково мають бути у варіанті.  
Лише один вузол з кожного блоку, помічений позначкою Core, включається до кожного варіанту (хоча можна реалізувати кілька таких завдань, щоб отримати додаткові бали).  
Деякі завдання помічені позначками Provides: ABC та Requires: ABC.  
Це означає, що в кожному варіанті перед вузлом з позначкою Requires: ABC десь вище в дереві має бути вузол з позначкою Provides: ABC.  
Це може бути безпосередньо батьківський вузол чи на далекій відстані у дереві, в тому ж блоці чи в іншому. 

Блок 0  
1. Реалізувати структуру даних для опису дерева з довільною кількістю «дітей». У вузлах дерева зберігаються цілі числа. Core.  

Блок 1 – додавання елементів до дерева  
4. Реалізувати функцію для додавання елемента до довільного дерева. Передається значення нового елемента та вірогідність p. З вірогідністю p новий елемент додається як дитина заданого вузла, з вірогідністю 1-p додається за тою самою процедурою до одного з дітей даного вузла (один з дітей обирається з однаковою вірогідністю). Core. Provides: ADD_PROC  

Блок 2 – вивід дерева  
8. Реалізувати функцію для виводу дерева з використанням відступів для виводу дітей різних рівнів. Core.

Блок 3 – видалення елементів  
15. Реалізувати функцію для видалення елементу з довільного дерева. Передається значення елементу (якщо є кілька елементів з таким значенням – видаляються всі вузли). Звільнити пам’ять видалених елементів. Core.  

Блок 4 – бінарні дерева (у всіх завданнях реалізувати також вивід дерева, на основі відповідної функції з блоку 2)  
18. Реалізувати структуру даних для опису бінарного дерева. Реалізувати функцію для додавання елементів відповідно до значення (менші значення наліво, всі інші направо). Core.  

Блок 5 – подання бінарних дерев  
21. Побудувати з бінарного дерева послідовне подання на основі прямого порядку.  

Блок 6 – використання дерев  
24. Реалізувати дерево для подання логічних виразів. Підтримуються константи (0 та 1) та змінні, а також операції AND, OR, NOT, XOR, імплікації, еквівалентності. Реалізувати спрощення виразів, обчислення константних підвиразів. Реалізувати обчислення значення виразу для заданих значень змінних. Реалізувати перевірку, що вираз є завжди істинним (тавтологія) чи завжди хибним (протиріччя).  


## Лаба 5
Блок 0
1. Реалізувати структуру даних граф на основі матриці суміжності.
2. Реалізувати структуру даних граф на основі структури суміжності.

Блок 1 – прості алгоритми на графах
Реалізувати алгоритм перевірки зв’язності графу.

Блок 2 – обхід графів. В цьому блоці реалізувати дві версії алгоритмів – сусіди заданого вузла обходяться в довільному порядку (наприклад, в порядку номерів вершин), та сусіди обходяться в порядку від найменшої до найбільшої ваги відповідних ребер.
Реалізувати алгоритм обходу графу в глибину.

Блок 3 – пошук шляхів мінімальної довжини. В цьому блоці реалізувати версії алгоритмів для пошуку шляху між двома заданими вершинами, від заданої вершини до всіх інших, між усіма вершинами графу. 
Розглянути випадки орієнтованого та неорієнтованого графів.
Реалізувати алгоритм Дейкстри.

Блок 4 – топологічне сортування 
Реалізувати алгоритм Кана.

Блок 5 – кістякові дерева. Реалізувати на основі обох версій обходу (див. блок 2). Розрахувати сумарну вагу дерева.
Реалізувати алгоритм побудови кістякового дерева на основі пошуку в глибину.

Блок 6 – мінімальні кістякові дерева. Розрахувати сумарну вагу дерева.
Реалізувати алгоритм побудови мінімального кістякового дерева (Kruskal).


## Лаба 6  
Cтворення пустого списку, додавання елементу, вилучення елементу, пошук елементів за значенням та за діапазоном значень, вивід елементів у правильному порядку, виконання певних дій над усіма елементами в правильному порядку.
Реалізувати структуру даних «впорядкований список» на основі:  
1. Зв’язного списку (Linked List)  
2. Списку на основі масиву (Array List)  
3. Бінарного дерева пошуку (без балансування)  
4. АВЛ-дерева  
5. 2-3 дерева  
Текстові рядки, спершу за довжиною, за спаданням